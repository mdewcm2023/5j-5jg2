var tipuesearch = {"pages": [{'title': 'About', 'text': 'Repo:\xa0 https://github.com/mdewcm2023/5j-5jg2 \xa0 \n site:\xa0 https://mdewcm2023.github.io/5j-5jg2/ \xa0 \n \n', 'tags': '', 'url': 'About.html'}, {'title': 'How to be a Star Engineer', 'text': '心得: \n 想要成為一名傑出的工程師 不一定要認真投入工作 能夠額外付出幫助同事並且能完成自身工作 \n 以下是關於如何成為一名優秀工程師的9個策略 \n \n 閃亮的軌跡 (Blazing trails) \n 知道該問誰 (Knowing who knows) \n 主動的自我管理 (Proactive self-management) \n 掌握全局 (Getting the big picture) \n 正確地追隨 (The right kind of followership) \n 團隊合作 (Teamwork as joint ownership of a project) \n 小領導者的領導風格 (Small-l leadership) \n 精明 (Street smarts) \n 呈現 (Show and tell) \n \n 第一個因素是技術知識和技能。工程師需要不斷學習和掌握最新的技術和工具，以保持競爭力。而這些技術知識和技能需要不斷地更新和提升，以跟上技術的發展。此外，良好的專業知識和經驗也是發揮領導作用的必要條件。 \n 第二個因素是溝通和協作能力。在現代工程領域中，很少有一個人能夠獨自完成整個項目。工程師需要與不同的團隊成員和部門合作，並能夠清晰地表達自己的想法和意見。如何建立良好的工作關係，以達到共同的目標也是重要的。 \n 第三個因素是自主學習和問題解決的能力。工程師需要有足夠的耐心和毅力來尋找解決方案，特別是在面對複雜的問題和挑戰時。工程師需要擅長運用科學的方法和技巧來解決問題，以達到更高的效率和創造力。 \n 最後，工程師需要對工作有熱情和動力。優秀工程師需要享受解決問題和創新的過程，並為自己的工作感到自豪和滿足。這種熱情和動力也會激勵工程師不斷地追求卓越和進步。 \n 總之，要成為一個優秀的工程師，不僅需要技術知識和技能，還需要溝通和協作能力、自主學習和問題解決能力，以及對工作的熱情和動力。這些特質和能力都可以通過不斷學習和實踐來提升，並且在職業生涯中持續發揮重要作用。 \n 當一個工程師表現平平時，通常不是因為他的能力不足。而是因為他從來沒有學過可以提高他生產力的工作策略。一旦他瞭解了這些策略，他就開始邁向傑出之路! \n', 'tags': '', 'url': 'How to be a Star Engineer.html'}, {'title': 'W11', 'text': '', 'tags': '', 'url': 'W11.html'}, {'title': 'TOEIC檢測簡介', 'text': '\xa0https://www.toeic.com.tw/toeic/listening-reading/about/introduction/ \n 多益英語測驗（TOEIC®）全名為Test of English for International Communication，是美國ETS®針對母語非英語人士所研發的英語能力測驗，全球每年有超過700萬人次報考。 \n 多益系列測驗（The TOEIC®Program）目前可於全球160個國家施測，至少為1萬4千個以上的企業客戶、教育單位及政府機構所採用。成績不僅具備信度與效度，也具有國際流通度，足以體現考生在實際溝通情境中的英語文能力。 \n TOEIC®Listening and Reading Test本身並沒有所謂的「通過」或「不通過」，而是客觀地將受測者的能力以聽力5～495分、閱讀5～495分、總分10～990分的指標呈現，受測者也可以自評現在的英語能力，進而設定學習的目標分數。 \n 在真實的職場與校園環境中，當需要以英語溝通時，透過多益系列測驗，成績使用單位能夠進一步掌握職員與學習者的能力現況。 \n 也因為多益系列測驗之國際流通度廣闊，眾多國內外企業、學校，皆採用多益系列測驗作為評核人才英語程度之標準。 \n', 'tags': '', 'url': 'TOEIC檢測簡介.html'}, {'title': 'TOEFL簡介', 'text': 'TOEFL iBT測驗包含四個部分，考生必須在3個小時內完成全部測驗。 \n \n 閱讀測驗–評量考生在大學校園求學時，閱讀課堂上的教材及文章之理解能力。 \n 聽力測驗–評量考生在大學校園中，對英語的口語聽力理解能力。 \n 口說測驗–評量考生在大學校園的學術環境下、使用英語進行口語表達的能力。 \n 寫作測驗–評量考生在大學校園的課堂上，能否適當的使用英語進行寫作的能力。 \n TOEFL iBT與TOEFL ITP有什麼不同？ \n \n 托福網路測驗(TOEFL iBT ® )與托福紙筆測驗(TOEFL ITP ® )二種測驗皆為ETS所研發的托福測驗，只是在測驗形態、測驗設備、題型及時間等執行測驗方式的不同，而二種托福測驗的出題大方向及測驗範疇相同，皆是針對個人的校園及學術英語能力進行評量，都是最有效的學術英語能力評量工具。由於二種測驗的後勤作業與成本並不相同，因此在測驗價格上也有很大的差別。  托福紙筆測驗(TOEFL ITP ® )是用紙、筆填寫答案卡方式，以選擇題方式測驗考生的聽力、文法結構與閱讀能力三大項目，目前不考口說與寫作。測驗對象是國際交換學生、條件式入學學生、語言學校、中等學校與成人學校的學生及大學國際化教育計劃的學生，而TOEFL ITP的成績也常做為社區學院與獎助計劃申請者之報名條件。完整測驗時間為115分鐘，測驗費用為新台幣1,200元。  托福網路測驗(TOEFL iBT ® )是現階段北美洲大學入學許可之認證考試，由原先之TOEFL CBT電腦型態測驗於2006年9月停辦後，所改制而成。托福網路測驗(TOEFL iBT ® )是使用電腦與耳機麥克風，透過網路即時連線至ETS進行線上測驗，考試範圍涵蓋「聽、說、讀、寫」四項技能，並採取整合技能(Integrated Skills)方試測驗，完整測驗時間為3小時 ，測驗費用為美金235元（約新台幣6,900元）。 \n', 'tags': '', 'url': 'TOEFL簡介.html'}, {'title': 'GRE簡介', 'text': '\n \n GRE全名為Graduate Record Examinations，是由GRE委員會委託美國教育測驗服務社ETS所主辦的美國研究所入學考試。GRE的一般適用對象為申請美國研究所（或博士）課程的學生，科系包含法律（碩士、JD）、MBA、商（管）學院專業型碩士（例如Finance、Marketing）、工程（Engineering）、科學（Science）、人文科學（Humanities），以及教育（Education）…等。除了申請者的大學成績、推薦信以及其他的備審文件（例如讀書計畫、申論題）外，GRE成績提供了美國各大學審核委員會（Admissions Committee）一個更客觀性的指標，來評估申請者就讀碩士（或博士）課程的資格與條件。 \n 除了GRE考試之外，部分學校也會要求申請人提供GRE Subject TEST的成績證明 \n \n \n', 'tags': '', 'url': 'GRE簡介.html'}, {'title': 'Brython', 'text': 'https://en.wikipedia.org/wiki/Python_(programming_language) \n Examples: \n https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d \n https://www.geeksforgeeks.org/python-programming-examples/ \n https://www.programiz.com/python-programming/examples \n https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/ \n Python Tutorial: \n https://docs.python.org/3/tutorial/ \n An informal introduction to Python \n Indentation (Python 採 4 個 Spaces 縮排, 以界定執行範圍) \n Variables ( Python Keywords ) \n Comments (# 單行註解, 三個單引號或三個雙引號標註多行註解) \n Numbers  (整數 int(), 浮點數 float()) \n Strings  (字串) \n print (Python 內建函式,  print()  函式) \n Python control flow tools \n for \n if \n range \n open \n read \n lists \n tuples \n dictionaries \n functions \n try ... except \n break \n pass \n classes \n 這個頁面 demo 如何在同一頁面下納入多個線上 Ace 編輯器與執行按鈕 ( practice_html.txt  動態頁面超文件). \n practice_html.txt  動態頁面超文件應該可以在啟動 Brython 時, 設定將 .py 檔案放入 downloads/py 目錄中引用. \n 亦即將所有對應的 html 也使用 Brython 產生, 然後寫為  class  後, 在範例導入時透過  instance  引用. \n <!-- 啟動 Brython -->\n<script>\nwindow.onload=function(){\nbrython({debug:1, pythonpath:[\'./../cmsimde/static/\',\'./../downloads/py/\']});\n}\n</script> \n 從 1 累加到 100: \n 1 add to 100 \n 將 iterable 與 iterator  相關說明 , 利用 Brython 與 Ace Editor 整理在這個頁面. \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris Rotating Block \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n \n', 'tags': '', 'url': 'Brython.html'}, {'title': 'Brython_ex2', 'text': 'This code uses the Euler method to approximate the solution to the ODE dy/dx = x - y with an initial condition of y0 = 1.0. The solution is calculated for a range of x values from 0 to 5. \n \n \n \n \n Solve ODE: \n from browser import document\n\ndef dy_dx(y, x):\n    return x - y\n\nx_start = 0\nx_end = 5\nn_points = 100\nx = [x_start + i * (x_end - x_start) / (n_points - 1) for i in range(n_points)]\ny0 = 1.0\nh = x[1] - x[0]\ny = [y0]\nfor i in range(1, len(x)):\n    y.append(y[-1] + h * dy_dx(y[-1], x[i-1]))\n\n# Create a new paragraph element and set its text content to the solution\np = document.createElement(\'p\')\np.textContent = f"The solution to the ODE is: {y}"\n\n# Append the paragraph element to the body of the webpage\ndocument.body.appendChild(p) \n \n \n \n \n \n Brython environment and  Plotly.js : \n <script src="./../cmsimde/static/brython.js"></script>\n<script src="./../cmsimde/static/brython_stdlib.js"></script>\n<script>// <![CDATA[\nwindow.onload=function(){\nbrython({debug:1, pythonpath:[\'./../cmsimde/static/\']});\n}\n// ]]></script>\n<p id="brython_div"></p> \n Brython programe with Plotly.js: \n from browser import document, window\n\ndef dy_dx(y, x):\n    return x - y\n\nx_start = 0\nx_end = 5\nn_points = 100\nx = [x_start + i * (x_end - x_start) / (n_points - 1) for i in range(n_points)]\ny0 = 1.0\nh = x[1] - x[0]\ny = [y0]\nfor i in range(1, len(x)):\n    y.append(y[-1] + h * dy_dx(y[-1], x[i-1]))\n\n# Create a new div element to hold the plot\n#plot_div = document.createElement(\'div\')\n#plot_div.id = \'plot\'\n#document.body.appendChild(plot_div)\nplot_div = document["brython_div"]\n\n# Plot the solution using plotly.js\ndata = [{\'x\': x, \'y\': y}]\nwindow.Plotly.newPlot(\'brython_div\', data) \n This code defines a function dy_dx that represents the mass-spring-damper ordinary differential equation. The Euler method is used to solve this equation for a range of x values from 0 to 20 with initial conditions of y0 = [1.0, 0.0]. The solution is then plotted on the webpage using  plotly.js . \n \n \n This code defines a function dy_dx that represents the mass-spring-damper system with a PID controller. The gains of the PID controller are set to Kp = 10.0, Ki = 1.0, and Kd = 0.5. The Euler method is used to solve this system of equations for a range of x values from 0 to 20 with initial conditions of y0 = [0.0, 0.0, 0.0, 0.0]. The response of the system is then plotted on the webpage using  plotly.js . \n \n \n \n \n \n \n \n STL part viewer \n \n \n Using  sine-cosine algorithm  to optimize with constraints in Brython: \n <!DOCTYPE html>\n<html>\n<head>\n    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/brython@3/dist/brython_stdlib"></script>\n</head>\n<body onload="brython()">\n\n<div id="output"></div>\n\n<script type="text/python">\nfrom browser import document\nfrom random import random, uniform\nfrom math import sin, cos, pi\n\n# Define the objective function\ndef objective_function(x):\n    return x[0]**2 + x[1]**2\n\n# Define the constraint functions\ndef constraint1(x):\n    return x[0] + x[1] - 2\n\ndef constraint2(x):\n    return 1 - x[0] - x[1]\n\n# Define the penalty function\ndef penalty_function(x):\n    penalty = 0\n    if constraint1(x) > 0:\n        penalty += constraint1(x)\n    if constraint2(x) > 0:\n        penalty += constraint2(x)\n    return penalty\n\n# Define the fitness function\ndef fitness_function(x):\n    return objective_function(x) + penalty_function(x)\n\n# Define the sine cosine algorithm\ndef sine_cosine_algorithm(fitness_function, dimension, lower_bound, upper_bound, population_size, max_iterations):\n    # Initialize the population\n    population = [[uniform(lower_bound, upper_bound) for _ in range(dimension)] for _ in range(population_size)]\n    population_fitness = [fitness_function(individual) for individual in population]\n\n    # Initialize the best solution\n    best_solution = population[0]\n    best_fitness = population_fitness[0]\n\n    # Main loop of the algorithm\n    for iteration in range(max_iterations):\n        # Calculate the value of a and r1\n        a = 2 - iteration * (2 / max_iterations)\n        r1 = 2 * pi * random()\n\n        # Update the population\n        for i in range(population_size):\n            # Calculate the value of r2, r3 and r4\n            r2 = 2 * random()\n            r3 = 2 * random()\n            r4 = random()\n\n            # Update the individual\n            for j in range(dimension):\n                if r4 < 0.5:\n                    population[i][j] += r1 * sin(r2) * abs(r3 * best_solution[j] - population[i][j])\n                else:\n                    population[i][j] += r1 * cos(r2) * abs(r3 * best_solution[j] - population[i][j])\n\n                # Make sure the individual is within the bounds\n                if population[i][j] < lower_bound:\n                    population[i][j] = lower_bound\n                elif population[i][j] > upper_bound:\n                    population[i][j] = upper_bound\n\n            # Calculate the fitness of the individual\n            population_fitness[i] = fitness_function(population[i])\n\n            # Update the best solution\n            if population_fitness[i] < best_fitness:\n                best_solution = population[i]\n                best_fitness = population_fitness[i]\n\n        # Print the current iteration and best fitness\n        print(f\'Iteration: {iteration + 1}, Best Fitness: {best_fitness:.6f}\')\n\n    return best_solution\n\n# Run the sine cosine algorithm to solve the optimization problem with constraints\nbest_solution = sine_cosine_algorithm(fitness_function, dimension=2, lower_bound=-10, upper_bound=10, population_size=50, max_iterations=100)\n\n# Print the result\noutput_div = document[\'output\']\noutput_div.text = f\'Best Solution: {best_solution}\'\n</script>\n\n<script src="https://cdn.jsdelivr.net/npm/brython@3/dist/brython"></script>\n</body>\n</html> \n Plot the result by using  plotly.js : \n <!DOCTYPE html>\n<html>\n<head>\n    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/brython@3/dist/brython_stdlib"></script>\n    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>\n</head>\n<body onload="brython()">\n\n<div id="output"></div>\n<div id="plot"></div>\n\n<script type="text/python">\nfrom browser import document\nfrom random import random, uniform\nfrom math import sin, cos, pi\n\n# Define the objective function\ndef objective_function(x):\n    return x[0]**2 + x[1]**2\n\n# Define the constraint functions\ndef constraint1(x):\n    return x[0] + x[1] - 2\n\ndef constraint2(x):\n    return 1 - x[0] - x[1]\n\n# Define the penalty function\ndef penalty_function(x):\n    penalty = 0\n    if constraint1(x) > 0:\n        penalty += constraint1(x)\n    if constraint2(x) > 0:\n        penalty += constraint2(x)\n    return penalty\n\n# Define the fitness function\ndef fitness_function(x):\n    return objective_function(x) + penalty_function(x)\n\n# Define the sine cosine algorithm\ndef sine_cosine_algorithm(fitness_function, dimension, lower_bound, upper_bound, population_size, max_iterations):\n    # Initialize the population\n    population = [[uniform(lower_bound, upper_bound) for _ in range(dimension)] for _ in range(population_size)]\n    population_fitness = [fitness_function(individual) for individual in population]\n\n    # Initialize the best solution\n    best_solution = population[0]\n    best_fitness = population_fitness[0]\n\n    # Main loop of the algorithm\n    for iteration in range(max_iterations):\n        # Calculate the value of a and r1\n        a = 2 - iteration * (2 / max_iterations)\n        r1 = 2 * pi * random()\n\n        # Update the population\n        for i in range(population_size):\n            # Calculate the value of r2, r3 and r4\n            r2 = 2 * random()\n            r3 = 2 * random()\n            r4 = random()\n\n            # Update the individual\n            for j in range(dimension):\n                if r4 < 0.5:\n                    population[i][j] += r1 * sin(r2) * abs(r3 * best_solution[j] - population[i][j])\n                else:\n                    population[i][j] += r1 * cos(r2) * abs(r3 * best_solution[j] - population[i][j])\n\n                # Make sure the individual is within the bounds\n                if population[i][j] < lower_bound:\n                    population[i][j] = lower_bound\n                elif population[i][j] > upper_bound:\n                    population[i][j] = upper_bound\n\n            # Calculate the fitness of the individual\n            population_fitness[i] = fitness_function(population[i])\n\n            # Update the best solution\n            if population_fitness[i] < best_fitness:\n                best_solution = population[i]\n                best_fitness = population_fitness[i]\n\n        # Print the current iteration and best fitness\n        print(f\'Iteration: {iteration + 1}, Best Fitness: {best_fitness:.6f}\')\n\n    return best_solution\n\n# Run the sine cosine algorithm to solve the optimization problem with constraints\nbest_solution = sine_cosine_algorithm(fitness_function, dimension=2, lower_bound=-10, upper_bound=10, population_size=50, max_iterations=100)\n\n# Print the result\noutput_div = document[\'output\']\noutput_div.text = f\'Best Solution: {best_solution}\'\n\n# Plot the result using Plotly.js\ndata = [\n    {\n        \'x\': [best_solution[0]],\n        \'y\': [best_solution[1]],\n        \'mode\': \'markers\',\n        \'marker\': {\'size\': 12},\n        \'name\': \'Best Solution\'\n    }\n]\n\nlayout = {\n    \'xaxis\': {\'range\': [-10, 10]},\n    \'yaxis\': {\'range\': [-10, 10]},\n}\n\nPlotly.newPlot(\'plot\', data, layout)\n</script>\n\n<script src="https://cdn.jsdelivr.net/npm/brython@3/dist/brython"></script>\n</body>\n</html> \n \n sine algorithm to solve the optimization problem with constraints best_solution = sine_cosine_algorithm(fitness_function, dimension=2, lower_bound=-10, upper_bound=10, population_size=50, max_iterations=100) # Print the result output_div = document[\'output\'] output_div.text = f\'Best Solution: {best_solution}\' # Plot the result using Plotly.js data = [ { \'x\': [best_solution[0]], \'y\': [best_solution[1]], \'mode\': \'markers\', \'marker\': {\'size\': 12}, \'name\': \'Best Solution\' } ] layout = { \'xaxis\': {\'range\': [-10, 10]}, \'yaxis\': {\'range\': [-10, 10]}, } Plotly.newPlot(\'plot\', data, layout) </script> <script src="https://cdn.jsdelivr.net/npm/brython@3/dist/brython"></script> </body> </html> \n', 'tags': '', 'url': 'Brython_ex2.html'}]};